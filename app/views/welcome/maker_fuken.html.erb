<h1>Arbor.js Canvas</h1>
<canvas id="viewport" width="800" height="600" style="border: 1px solid black"></canvas>
<script type="text/javascript" charset="utf-8">
  (function($){
    var Renderer = function(canvas){
      var canvas = $(canvas).get(0);
      var ctx = canvas.getContext('2d');
      var particleSystem;

      var self = {
        // this is called just once, when the particle system is started
        // right before the first frame is drawn
        // setup canvas and canvas size here
        init: function(system){
          // save a reference to the particle system
          particleSystem = system;

          // this function must be called every time screen is resized
          // passing the new dimensions as params
          particleSystem.screenSize(canvas.width, canvas.height);
          particleSystem.screenPadding(80);

          // set up event handlers for node dragging
          self.initMouseHandling();
        },
        // this function is called every time the positions are changed
        // you can access the position of a node using the .p attribute
        // which has a .x and a .y property
        // particleSystem the convenience methods .eachNode and .eachEdge methods
        // that work like [].forEach
        redraw: function(){
          ctx.fillStyle = 'white';
          ctx.fillRect(0,0, canvas.width, canvas.height);

          // edge: {source: Node, target: Node, length: Number, data: Object}
          // pt1:  {x: Number, y: Number} position of vertex 1 in screen coordinates
          // pt2:  {x: Number, y: Number} position of vertex 2 in screen coordinates
          particleSystem.eachEdge(function(edge, pt1, pt2){
            // draw a line from pt1 to pt2
            ctx.strokeStyle = "rgba(0, 0, 0, .333)";
            ctx.lineWidth   = 1;
            ctx.beginPath();
            ctx.moveTo(pt1.x, pt1.y);
            ctx.lineTo(pt2.x, pt2.y);
            ctx.stroke();
          });

          // node: {mass: Number, p:{x, y}, name: String, data: Object }
          // p:    {x: Number, y: Number} position of the node in screen coords
          particleSystem.eachNode(function(node, pt){
            // draw a rectangle circle at "pt"
            var width = 10;
            ctx.fillStyle = (node.data.alone) ? "orange": "black";
            // x, y, width, height
            ctx.fillRect(pt.x - width/2, pt.y - width/2, width, width);
          });
        },
        initMouseHandling: function(){
          // no non-sense drag and drop thanks to springy.js
          var dragged = null;

          // set up a handler that will listen for mousedown events
          // then it will listen for moves and mouseups while dragging
          var handler = {
            clicked: function(e){
              var pos = $(canvas).offset();
              // Â¿variable global?
              _mouseP = arbor.Point(e.pageX - pos.left, e.pageY - pos.top);
              dragged = particleSystem.nearest(_mouseP);

              if(dragged && dragged.node !== null){
                // don't let physics move the node while we are dragging it
                dragged.node.fixed = true;
              }

              $(canvas).bind('mousemove', handler.dragged);
              $(window).bind('mouseup',   handler.dragged);

              return false;
            },
            dragged: function(e){
              var pos               = $(canvas).offset();
              var point_from_screen = arbor.Point(e.pageX - pos.left, e.pageY - pos.top);

              if(dragged && dragged.node !== null){
                var point = particleSystem.fromScreen(point_from_screen);
                dragged.node.p = point;
              }

              return false;
            },
            dropped: function (e) {
              if(dragged == null || dragged.node === undefined){
                return;
              }
              if(dragged.node !== null){
                dragged.node.fixed = false;
              }
              dragged.node.tempMass = 1000;
              dragged = null;

              $(canvas).unbind('mousemove', handler.dragged);
              $(window).unbind('mouseup',   handler.dropped);

              _mouseP = null;

              return false;
            }
          };

          // start listening
          $(canvas).mousedown(handler.clicked);
        }
      };
      return self;
    }

    $(document).ready(function(){
      // repulsion, stiffness, friction
      var sys = arbor.ParticleSystem(1000, 600, 0.5);

      sys.parameter({gravity: true}); // use center-gravity
      sys.renderer = Renderer("#viewport"); // the .init() method on Renderer will be shortly called by sys

      // add some nodes
      sys.addEdge('a', 'b');
      sys.addEdge('a', 'c');
      sys.addEdge('a', 'd');
      sys.addEdge('a', 'e');
      sys.addNode('f', {alone: true, mass: 25});

      // or, equivalently:
      //
      // sys.graft({
      //   nodes:{
      //     f:{alone:true, mass:.25}
      //   },
      //   edges:{
      //     a:{ b:{},
      //         c:{},
      //         d:{},
      //         e:{}
      //     }
      //   }
      // })

    });

  }(this.jQuery))
</script>
