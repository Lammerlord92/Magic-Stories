<!-- Page passes the container for the graph to the program -->
<head>
  <div>

    <style>
      #graphContainer{
        position:relative;
        overflow:auto;
        left:0px;
        bottom:0px;
        right:0px;
        width:100%;
        height:100%;
        border:solid 2px darkgrey;
        cursor:default;
      }
      #properties{
        border:  solid 2px darkgrey;
        padding: 10px;
      }

      /* Show the dropdown menu (use JS to add this class to the .dropdown-content container when the user clicks on the dropdown button) */
      .show {display:block;}
    </style>

    <!--
    <table width="100%" height="100%" border="0" cellspacing="0" cellpadding="0">
      <tr>
        <td id="toolbox" valign="top" width="70px" style="min-width:70px;background:#7F7F7F;padding:12px;">
          <img src="http://etc.usf.edu/clipart/40600/40690/pb_sq_40690_lg.gif" width="70px" height="70px"><br/>
          <img src="http://2.bp.blogspot.com/-MZAjo7HkgNE/TqUZQPShXQI/AAAAAAAAB9c/c5Xy3HBhk_g/s1600/GlobeCircle+copy.png" width="70px" height="70px"><br/>
        </td>
        <td>
          <div id="graphContainer"></div>
          <br>
          <div id="properties">
            <input type="text" name="lastname" id="my_textTitle">
          </div>
        </td>
      </tr>
    </table> -->



    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
      mxBasePath = '../src';
    </script>

    <!-- Loads and initializes the library -->
    <!--<script type="text/javascript" src="/assets/javascripts/mxClient.js"></script>-->
    <script type="text/javascript" src="../../assets/javascripts/widgEditor.js"></script>

    <!-- Example code -->
    <script type="text/javascript">

      // fuken: Esta funcion de jQuery carga la funcion main
      //        cuando el html ha sido cargado entero
      $(document).ready(function main() {
        window.edit2Bool = false;
        var container = document.getElementById('graphContainer');
        // Checks if the browser is supported
        if (!mxClient.isBrowserSupported()) {
          // Displays an error message if the browser is not supported.
          mxUtils.error('Browser is not supported!', 200, false);
        }
        else {
          // Note that these XML nodes will be enclosing the
          // mxCell nodes for the model cells in the output
          var xml = mxUtils.createXmlDocument();

          var chapter1 = xml.createElement('Chapter');
          chapter1.setAttribute('title', 'Capítulo 01');
          chapter1.setAttribute('body', 'Este es el texto del capítulo 01. Este capítulo no puede borrarse, ya que es el primer capítulo de tu historia. Puedes crear nuevos capítulos y enlaces mediante los botones de la izquierda.');
          chapter1.setAttribute('graphIndex','initialChapter01');

          /*var chapter2 = xml.createElement('Chapter');
           chapter2.setAttribute('title', 'Juanoide pone la numeración');
           chapter2.setAttribute('body', 'Juanoide ha hecho las cosas bien');
           chapter2.setAttribute('graphIndex','chapter02');

           var chapter3 = xml.createElement('Chapter');
           chapter3.setAttribute('title', 'El grupo 1 se queja');
           chapter3.setAttribute('body', 'Buuuuu');
           chapter3.setAttribute('graphIndex','chapter03');

           var chapter4 = xml.createElement('Chapter');
           chapter4.setAttribute('title', 'Juanoide no pone la numeración');
           chapter4.setAttribute('body', 'Juanoide no ha hecho las cosas bien');
           chapter4.setAttribute('graphIndex','chapter04');

           var relation = xml.createElement('sendTo');
           relation.setAttribute('since', '1985');*/

          //Creates a list of chapters
          window.chapterArray = [];

          // Creates the graph inside the given container
          window.graph = new mxGraph(container);

          // fuken: sacar el objeto graph como propiedad global
          //        para poder verlo en la consola del navegador
          window.gr = graph;

          // Optional disabling of sizing
          graph.setCellsResizable(false);

          //Javi: No permite mover flechas
          graph.setAllowDanglingEdges(false);


          // Configures the graph contains to resize and
          // add a border at the bottom, right
          graph.setResizeContainer(true);
          graph.minimumContainerSize = new mxRectangle(0, 0, 500, 380);
          graph.setBorder(60);

          // Stops editing on enter key, handles escape
          new mxKeyHandler(graph);

          // Overrides method to disallow edge label editing
          graph.isCellEditable = function (cell) {
            return !this.getModel().isEdge(cell);
          };

          // Overrides method to provide a cell label in the display
          graph.convertValueToString = function (cell) {
            if (mxUtils.isNode(cell.value)) {
              if (cell.value.nodeName.toLowerCase() == 'chapter') {
                var title = cell.getAttribute('title', '');
                var body  = cell.getAttribute('body', '');

                if (body != null && body.length > 0) {
                  //return body + ', ' + title;
                  return title;
                }

                return title;
              }
              else if (cell.value.nodeName.toLowerCase() == 'sendTo') {
                return cell.value.nodeName + ' (Since '
                    + cell.getAttribute('since', '') + ')';
              }

            }

            return '';
          };

          // Overrides method to store a cell label in the model
          var cellLabelChanged = graph.cellLabelChanged;
          graph.cellLabelChanged = function (cell, newValue, autoSize) {
            if (mxUtils.isNode(cell.value) &&
                cell.value.nodeName.toLowerCase() == 'chapter') {
              var pos = newValue.indexOf(' ');

              var title = (pos > 0) ? newValue.substring(0,pos)                    : newValue;
              var body  = (pos > 0) ? newValue.substring(pos + 1, newValue.length) : '';

              // Clones the value for correct undo/redo
              var elt = cell.value.cloneNode(true);

              elt.setAttribute('title', title);
              elt.setAttribute('body', body);

              newValue = elt;
              autoSize = true;
            }

            cellLabelChanged.apply(this, arguments);
          };

          // Overrides method to create the editing value
          var getEditingValue = graph.getEditingValue;
          graph.getEditingValue = function (cell) {
            if (mxUtils.isNode(cell.value) &&
                cell.value.nodeName.toLowerCase() == 'chapter') {
              var title = cell.getAttribute('title', '');
              var body = cell.getAttribute('body', '');

              return title + ' ' + body;
            }
          };

          // Adds a special tooltip for edges
          graph.setTooltips(true);

          var getTooltipForCell = graph.getTooltipForCell;
          graph.getTooltipForCell = function (cell) {
            // Adds some relation details for edges
            if (graph.getModel().isEdge(cell)) {
              var src = this.getLabel(this.getModel().getTerminal(cell, true));
              var trg = this.getLabel(this.getModel().getTerminal(cell, false));

              return src + ' ' + cell.value.nodeName + ' ' + trg;
            }

            return getTooltipForCell.apply(this, arguments);
          };

          // Enables rubberband selection
          new mxRubberband(graph);

          // Adds an option to view the XML of the graph
          /*document.querySelector('#bodyCol').appendChild(mxUtils.button('View XML', function () {
           var encoder = new mxCodec();
           var node = encoder.encode(graph.getModel());
           mxUtils.popup(mxUtils.getPrettyXml(node), true);
           }));*/


          document.querySelector('#bodyCol').appendChild(mxUtils.button('View JSON', function () {
            var encoder = new mxCodec();
            var node = encoder.encode(graph.getModel());
            //mxUtils.popup(mxUtils.getPrettyXml(node), true);

            //Esto nos coge todos los vertices del grafo
            var vertices = graph.getChildVertices(graph.getDefaultParent());
            var content = [];
            //var hijos = [];
            var padres = [];
            var storyid = <%= @id %>;
            window.alert("StoryId :" + storyid);
            for (i=0; i< vertices.length;i++) {

              //Sacamos todos los hijos de cada uno de los vertices del grafo
              var hijos = vertices[i].edges;

              //window.alert("Empieza el parseo!!");
              //window.alert("Numero de vertices actual " + vertices.length);
              //window.alert("Esta es la i actual " +i);
              var jsonFinal = pasarAJSON(storyid,vertices[i], hijos);
              window.alert("TErmina parseo")

              mxUtils.popup(jsonFinal, true);
            }
            console.log("Este es el jsonFinal" + jsonFinal);
          }));

          // Changes the style for match the markup
          // Creates the default style for vertices
          var style = graph.getStylesheet().getDefaultVertexStyle();
          style[mxConstants.STYLE_STROKECOLOR] = 'gray';
          style[mxConstants.STYLE_ROUNDED] = true;
          style[mxConstants.STYLE_SHADOW] = true;
          style[mxConstants.STYLE_FILLCOLOR] = '#DFDFDF';
          style[mxConstants.STYLE_GRADIENTCOLOR] = 'white';
          style[mxConstants.STYLE_FONTCOLOR] = 'black';
          style[mxConstants.STYLE_FONTSIZE] = '12';
          style[mxConstants.STYLE_SPACING] = 4;

          // Creates the default style for edges
          style = graph.getStylesheet().getDefaultEdgeStyle();
          style[mxConstants.STYLE_STROKECOLOR] = '#0C0C0C';
          style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = 'white';
          style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
          style[mxConstants.STYLE_ROUNDED] = true;
          style[mxConstants.STYLE_FONTCOLOR] = 'black';
          style[mxConstants.STYLE_FONTSIZE] = '10';

          // Gets the default parent for inserting new cells. This
          // is normally the first child of the root (ie. layer 0).
          var parent = graph.getDefaultParent();

          // Adds cells to the model in a single step
          graph.getModel().beginUpdate();
          try {
            //var w = chapter1.getAttribute('title').length * 7;

            var v1 = graph.insertVertex(parent, null, chapter1, 40, 40, chapter1.getAttribute('title').length * 7, 30);
            /*var v2 = graph.insertVertex(parent, null, chapter2, 200, 150, chapter2.getAttribute('title').length * 7, 30);
             var v3 = graph.insertVertex(parent, null, chapter3, 450, 125, chapter3.getAttribute('title').length * 7, 30);
             var v4 = graph.insertVertex(parent, null, chapter4, 200, 100, chapter4.getAttribute('title').length * 7, 30);

             var e1 = graph.insertEdge(parent, null, relation, v1, v2);
             var e2 = graph.insertEdge(parent, null, relation, v2, v3);
             var e3 = graph.insertEdge(parent, null, relation, v1, v4);
             var e4 = graph.insertEdge(parent, null, relation, v4, v3);*/
          }
          finally {
            // Updates the display
            graph.getModel().endUpdate();
          }

          // Implements a properties panel that uses
          // mxCellAttributeChange to change properties
          graph.getSelectionModel().addListener(mxEvent.CHANGE, function (sender, evt) {
            selectionChanged(graph);
          });

          selectionChanged(graph);
        }

        /**
         * Updates the properties panel
         */
        function selectionChanged(graph) {
          var cell = null;
          //var div = document.getElementById('properties');

          // Forces focusout in IE
          graph.container.focus();

          // Clears the DIV the non-DOM way
          //div.innerHTML = '';

          // Gets the selection cell
          cell = graph.getSelectionCell();

          graph.edge
          //Global variables
          window.savedCell = null;
          window.savedGraph = null;

          if (cell == null) {
            //var changingObject = $("#my_textBodyWidgIframe").contents().set('body','aahahahaha');
            $('#properties').hide();

            document.getElementById("my_textTitle").value = "Nothing selected";
            edit2Bool = false;
            console.log("Al no tener seleccionado nada, edit2Bool = "+edit2Bool);
          }
          else {
            console.log("Tras seleccionar un nodo, edit2Bool = "+edit2Bool);
            if (edit2Bool == true) {
              console.log("Entra en edit2Bool == true");
              $('#properties').hide();

              var attrs = cell.value.attributes;
              console.log("attrs(2) del nodo clickeado es = "+attrs[2].nodeValue);
              if (chapterArray[0] == null || chapterArray[0] != attrs[2].nodeValue){
                chapterArray.push(attrs[2].nodeValue);
              }

              if(chapterArray.length === 2){
                console.log("El array ya tiene 2 elementos");
                crearNuevaArista3(chapterArray);
              }

              console.log("Valor del array = "+chapterArray);
            }
            else{
              $('#properties').show();
              //var buttonAux = $("#submitButtonId");
              var buttonAux = document.getElementById("submitButtonId");
              //Change global variables
              savedCell = cell;
              savedGraph = graph;

              if (cell.value.nodeName.toLowerCase() == 'chapter') {
                $('#editor').show();
                var attrs = cell.value.attributes;

                for (var i = 0; i < attrs.length; i++) {
                  if (i == 0) { //Obtains the title
                    setFormTitleValue(attrs[i], cell, graph);
                  } else if(i==1){ //Obtains the body
                    var data = attrs[i];
                    var titleValue = data.value;

                    //widgEditor("my_textBody",titleValue);
                    setFormBodyValue(titleValue,cell,graph);
                  }
                  else if(i==2){
                    document.getElementById("my_ownId").value = attrs[i].nodeValue;
                  }
                }
                //mxUtils.br(div);
              }
              else {
                var attrs = cell.value.attributes;
                setFormTitleValue(attrs[0], cell, graph);
                $('#editor').hide();
              }
            }




          } //BABLBALBAB


        }


        function setFormTitleValue(titleValue,cell,graph){
          document.getElementById("my_textTitle").value = titleValue.nodeValue;
          var inputTitle=document.getElementById("my_textTitle");

          //Check if the title value is different from the previous one and changes it
          var applyHandler = function () {
            var newValue = inputTitle.value || '';
            var oldValue = titleValue.nodeValue;

            if (newValue != oldValue) {
              graph.getModel().beginUpdate();
              try {
                var edit = new mxCellAttributeChange(
                    cell, titleValue.nodeName,
                    newValue);
                graph.getModel().execute(edit);
                graph.updateCellSize(cell);
              }
              finally {
                graph.getModel().endUpdate();
                graph=null;
              }
            }
          };

          /*
           mxEvent.addListener(inputTitle, 'keypress', function (evt) {
           // Needs to take shift into account for textareas
           if (evt.keyCode == /*enter*//*13 && !mxEvent.isShiftDown(evt)) {
           inputTitle.blur();
           }
           });

           mxEvent.addListener(inputTitle, 'blur', applyHandler);

           //graph=null;*/
        }



        function setFormBodyValue(bodyValue,cell,graph) {
          //document.getElementById("my_textBody").value = bodyValue.nodeValue;
          widgEditor("my_textBody",bodyValue);
          var inputBody = document.getElementById("my_textBodyWidgIframe");
          var iFrameContent = $("#my_textBodyWidgIframe").contents();

          //Check if the body value is different from the previous one and changes it

          var applyHandler = function () {
            var newValue = inputBody.value || '';
            var oldValue = bodyValue.nodeValue;

            if (newValue != oldValue) {
              graph.getModel().beginUpdate();
              try {
                var edit = new mxCellAttributeChange(
                    cell, bodyValue.nodeName,
                    newValue);
                graph.getModel().execute(edit);
                graph.updateCellSize(cell);
              }
              finally {
                graph.getModel().endUpdate(); graph=null;
              }
            }
            else{
            }
          };


          mxEvent.addListener(inputBody, 'keypress', function (evt) {
            // Needs to take shift into account for textareas
            if (evt.keyCode == /*enter*/13 && !mxEvent.isShiftDown(evt)) {
              inputTitle.blur();
            }
          });

          if (mxClient.IS_IE) {
            mxEvent.addListener(inputBody, 'focusout', applyHandler);
          }
          else {
            // Note: Known problem is the blurring of fields in
            // Firefox by changing the selection, in which case
            // no event is fired in FF and the change is lost.
            // As a workaround you should use a local variable
            // that stores the focused field and invoke blur
            // explicitely where we do the graph.focus above.
            mxEvent.addListener(inputBody, 'blur', applyHandler);
          }

          //graph = null;

        }

      });
    </script>

  </div>



</head>



<body>


<table width="100%" height="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td id="toolbox" valign="top" width="70px" style="min-width:70px;background:#7F7F7F;padding:12px;">
      <!--<img src="http://etc.usf.edu/clipart/40600/40690/pb_sq_40690_lg.gif" width="70px" height="70px"><br/>
      <img src="http://2.bp.blogspot.com/-MZAjo7HkgNE/TqUZQPShXQI/AAAAAAAAB9c/c5Xy3HBhk_g/s1600/GlobeCircle+copy.png" width="70px" height="70px"><br/>-->
      <button id="createNewNodeId" name="createNewNodeName" onclick="crearNuevoNodo()">Nuevo Nodo</button>
      <button id="creaetNewEdgeId" name="createNewEdgeName" onclick="crearNuevaArista2()">Nueva Arista</button>
      <button id="deleteId" name="deleteName" onclick="eliminar()">Eliminar</button>
      <button id="centrarId" name="centrarName" onclick="centrar()">Centrar</button>
      <button id="derechaId" name="derechaName" onclick="derecha()">Derecha</button>
      <button id="izquierdaId" name="izquierdaName" onclick="izquierda()">Izquierda</button>
      <button id="justificarId" name="justificarName" onclick="justificar()">Justificar</button>
    </td>
    <td>
      <div id="graphContainer">
      </div>
      <br>

      <div id="properties">

        <!--<input type="button" value="B" onclick=""/>-->
        <div id="container">
          <label for="noise">Title</label>
          <input type="text" id="my_textTitle" name="noise">
          <br/>
          <div id="editor">
            <label for="noise">Body</label>

            <input id="my_textBody" name="noise" class="widgEditor nothing"/>

            <!-- Esto sería para guardar la id del nodo actual, que nos servirá para crear los enlaces necesarios -->
            <br/>

            <button id="submitButtonId" name="submitButtonName" onclick="actualizaNodo()"> Guardar</button>
          </div>
        </div>
      </div>

    </td>
  </tr>
</table>

<script>
  alert("Estas editando la historia con id "+<%= @id %>)
</script>

</body>
</html>