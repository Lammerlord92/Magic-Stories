<!--
  Copyright (c) 2006-2013, JGraph Ltd

  Dynamic toolbar example for mxGraph. This example demonstrates changing the
  state of the toolbar at runtime.
-->
<html>
<head>
  <title>Toolbar example for mxGraph</title>

  <!-- Sets the basepath for the library if not in same directory -->
  <script type="text/javascript">
    mxBasePath = '../src';
  </script>

  <!-- Loads and initializes the library -->
  <script type="text/javascript" src="../src/js/mxClient.js"></script>

  <!-- Example code -->
  <script type="text/javascript">
    // Program starts here. Creates a sample graph in the
    // DOM node with the specified ID. This function is invoked
    // from the onLoad event handler of the document (see below).
    function main()
    {
      // Checks if browser is supported
      if (!mxClient.isBrowserSupported())
      {
        // Displays an error message if the browser is
        // not supported.
        mxUtils.error('Browser is not supported!', 200, false);
      }
<<<<<<< HEAD
      else
      {
        // Defines an icon for creating new connections in the connection handler.
        // This will automatically disable the highlighting of the source vertex.
        mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16);

        // Creates the div for the toolbar
        var tbContainer = document.createElement('div');
        tbContainer.style.position = 'absolute';
        tbContainer.style.overflow = 'hidden';
        tbContainer.style.padding = '2px';
        tbContainer.style.left = '0px';
        tbContainer.style.top = '0px';
        tbContainer.style.width = '24px';
        tbContainer.style.bottom = '0px';

        document.body.appendChild(tbContainer);

        // Creates new toolbar without event processing
        var toolbar = new mxToolbar(tbContainer);
        toolbar.enabled = false

        // Creates the div for the graph
        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.overflow = 'hidden';
        container.style.left = '24px';
        container.style.top = '0px';
        container.style.right = '0px';
        container.style.bottom = '0px';
        container.style.background = 'url("editors/images/grid.gif")';

        document.body.appendChild(container);

        // Workaround for Internet Explorer ignoring certain styles
        if (mxClient.IS_QUIRKS)
        {
          console.log("Entra en IS_QUIRKS");
          document.body.style.overflow = 'hidden';
          new mxDivResizer(tbContainer);
          new mxDivResizer(container);
=======
      else {
        // Note that these XML nodes will be enclosing the
        // mxCell nodes for the model cells in the output
        var xml = mxUtils.createXmlDocument();

        var chapter1 = xml.createElement('Chapter');
        chapter1.setAttribute('title', 'Juanoide presenta');
        chapter1.setAttribute('body', 'Juan ha ido a ISPP');

        var chapter2 = xml.createElement('Chapter');
        chapter2.setAttribute('title', 'Juanoide pone la numeración');
        chapter2.setAttribute('body', 'Juanoide ha hecho las cosas bien');

        var chapter3 = xml.createElement('Chapter');
        chapter3.setAttribute('title', 'El grupo 1 se queja');
        chapter3.setAttribute('body', 'Buuuuu');

        var chapter4 = xml.createElement('Chapter');
        chapter4.setAttribute('title', 'Juanoide no pone la numeración');
        chapter4.setAttribute('body', 'Juanoide no ha hecho las cosas bien');

        var relation = xml.createElement('sendTo');
        relation.setAttribute('since', '1985');

        // Creates the graph inside the given container
        window.graph = new mxGraph(container);

        // fuken: sacar el objeto graph como propiedad global
        //        para poder verlo en la consola del navegador
        window.gr = graph;

        // Optional disabling of sizing
        graph.setCellsResizable(false);

        //Javi: No permite mover flechas
        graph.setAllowDanglingEdges(false);


        // Configures the graph contains to resize and
        // add a border at the bottom, right
        graph.setResizeContainer(true);
        graph.minimumContainerSize = new mxRectangle(0, 0, 500, 380);
        graph.setBorder(60);

        // Stops editing on enter key, handles escape
        new mxKeyHandler(graph);

        // Overrides method to disallow edge label editing
        graph.isCellEditable = function (cell) {
          return !this.getModel().isEdge(cell);
        };

        // Overrides method to provide a cell label in the display
        graph.convertValueToString = function (cell) {
          if (mxUtils.isNode(cell.value)) {
            if (cell.value.nodeName.toLowerCase() == 'chapter') {
              var title = cell.getAttribute('title', '');
              var body  = cell.getAttribute('body', '');

              if (body != null && body.length > 0) {
                //return body + ', ' + title;
                return title;
              }

              return title;
            }
            else if (cell.value.nodeName.toLowerCase() == 'sendTo') {
              return cell.value.nodeName + ' (Since '
                  + cell.getAttribute('since', '') + ')';
            }

          }

          return '';
        };

        // Overrides method to store a cell label in the model
        var cellLabelChanged = graph.cellLabelChanged;
        graph.cellLabelChanged = function (cell, newValue, autoSize) {
          if (mxUtils.isNode(cell.value) &&
              cell.value.nodeName.toLowerCase() == 'chapter') {
            var pos = newValue.indexOf(' ');

            var title = (pos > 0) ? newValue.substring(0,pos)                    : newValue;
            var body  = (pos > 0) ? newValue.substring(pos + 1, newValue.length) : '';

            // Clones the value for correct undo/redo
            var elt = cell.value.cloneNode(true);

            elt.setAttribute('title', title);
            elt.setAttribute('body', body);

            newValue = elt;
            autoSize = true;
          }

          cellLabelChanged.apply(this, arguments);
        };

        // Overrides method to create the editing value
        var getEditingValue = graph.getEditingValue;
        graph.getEditingValue = function (cell) {
          if (mxUtils.isNode(cell.value) &&
              cell.value.nodeName.toLowerCase() == 'chapter') {
            var title = cell.getAttribute('title', '');
            var body = cell.getAttribute('body', '');

            return title + ' ' + body;
          }
        };

        // Adds a special tooltip for edges
        graph.setTooltips(true);

        var getTooltipForCell = graph.getTooltipForCell;
        graph.getTooltipForCell = function (cell) {
          // Adds some relation details for edges
          if (graph.getModel().isEdge(cell)) {
            var src = this.getLabel(this.getModel().getTerminal(cell, true));
            var trg = this.getLabel(this.getModel().getTerminal(cell, false));

            return src + ' ' + cell.value.nodeName + ' ' + trg;
          }

          return getTooltipForCell.apply(this, arguments);
        };

        // Enables rubberband selection
        new mxRubberband(graph);

        // Adds an option to view the XML of the graph
        document.querySelector('#bodyCol').appendChild(mxUtils.button('View XML', function () {
          var encoder = new mxCodec();
          var node = encoder.encode(graph.getModel());
          mxUtils.popup(mxUtils.getPrettyXml(node), true);
        }));




        document.querySelector('#bodyCol').appendChild(mxUtils.button('View JSON', function () {
          var encoder = new mxCodec();
          var node = encoder.encode(graph.getModel());
          //mxUtils.popup(mxUtils.getPrettyXml(node), true);

          //Esto nos coge todos los vertices del grafo
          var vertices = graph.getChildVertices(graph.getDefaultParent());
          var content = [];
          //var hijos = [];
          var padres = [];
         for (i=0; i< vertices.length;i++) {

           //Sacamos todos los hijos de cada uno de los vertices del grafo
           var hijos = vertices[i].edges;

           //window.alert("Empieza el parseo!!");
           //window.alert("Numero de vertices actual " + vertices.length);
           //window.alert("Esta es la i actual " +i);
           var jsonFinal = pasarAJSON(vertices[i], hijos);
           window.alert("TErmina parseo")

           mxUtils.popup(jsonFinal, true);
         }

            function pasarAJSON(vertice, hijos){

              var verticeId = vertice.id;
              var verticeTitle = vertice.value.attributes[0].nodeValue;
              var verticeBody = vertice.value.attributes[1].nodeValue;

              window.alert("Sigue bien1!!");
              console.log(vertice);
              //JSON inicial
              var json = '{"id":' + verticeId + ',"title":' + verticeTitle + ',"body":' + verticeBody +
                  ',"child_options":[';

              console.log("Todos los hijos " + hijos[0].source.id);
              window.alert("Sigue bien1!!");

              try{
                for(j=0;j<hijos.length;j++) {
                  if (j != hijos.length - 1) {
                    window.alert("Entra aqui bien 2!!");
                    //Hay que comprobar que el id del hijo no sea el mismo del padre
                    console.log("J" + j);
                    var sourceId = hijos[j].source.id;
                    var targetId = hijos[j].target.id;

                    console.log("SourceId" + sourceId);
                    console.log("TargetId" + targetId);

                    //Compruebo que el vertice origen sea yo mismo, eso quiere decir que la arista sale de mi, soy el padre
                    if(sourceId==verticeId){
                      console.log("SourceIdDentro" + sourceId);
                      console.log("VerticeActualId" + verticeId);

                      //TODO NO ME LO PILLA PORQUE EL EDGES SON DOS (0,1)
                      var optionTitle = hijos[j].value.attributes[0].nodeValue;
                      console.log(optionTitle);

                      //var hijoTitle = vertices[targetId].value.attributes[0].nodeValue;

                      json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + optionTitle + '"},';
                      console.log("1" + json);
                    }else{
                      if(targetId==verticeId){
                        //No hace nada porque ya esta presente en el JSON
                        //json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + hijoTitle + '"},';
                      }else{ //Soy el padre del nodo cuyo id sea el targetId
                        var optionTitle = hijos[j].value.attributes[0].nodeValue;
                        console.log(optionTitle);
                        //var hijoTitle = vertices[targetId].value.attributes[0].nodeValue;
                        json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + optionTitle + '"},';
                        console.log("2" + json);
                      }
                    }
                  } else {
                    window.alert("Entra aqui en el 3!!!");
                    //Hay que comprobar que el id del hijo no sea el mismo del padre
                    var sourceId = hijos[j].source.id;
                    var targetId = hijos[j].target.id;

                    console.log("SourceId" + sourceId);
                    console.log("TargetId" + targetId);

                    //Compruebo que el vertice origen sea yo mismo, eso quiere decir que la arista sale de mi, soy el padre
                    if(sourceId==verticeId){
                      window.alert("Entra aqui 4!!");
                      //var hijoTitle = vertices[targetId].value.attributes[0].nodeValue;
                      var optionTitle = hijos[j].value.attributes[0].nodeValue;
                      console.log(optionTitle);
                      json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + optionTitle + '"}],';
                      console.log("3" + json);
                    }else{
                      if(targetId==verticeId){
                        //No hace nada porque ya esta presente en el JSON
                        json += '],';
                        //json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + hijoTitle + '"},';
                      }else{ //Soy el padre del nodo cuyo id sea el targetId
                        var hijoTitle = vertices[targetId].value.attributes[0].nodeValue;
                        json += '{"child_id":' + targetId + ',"parent_id":' + sourceId + ',"option":' + hijoTitle + '"}],';
                        console.log("4" + json);
                      }
                    }
                  }
                }
              }
              finally {
                for(j=0;j<hijos.length;j++) {
                  if (j != hijos.length - 1) {
                    var sourceId = hijos[j].source.id;
                    var targetId = hijos[j].target.id;

                    console.log("SourceId" + sourceId);
                    console.log("TargetId" + targetId);

                    //Me queda comprobar mirar apuntes y borrar de arriba el parent_options
                    if(targetId==verticeId){
                      json += '"parent_options":[{' + sourceId + '}';
                    }else{
                      json += '"parent_options":[';
                    }

                  }else{
                    var sourceId = hijos[j].source.id;
                    var targetId = hijos[j].target.id;

                    console.log("SourceId" + sourceId);
                    console.log("TargetId" + targetId);

                    //Me queda comprobar mirar apuntes y borrar de arriba el parent_options
                    if(sourceId==verticeId){
                      json += ']}';
                    }else{
                      json += ',{' + sourceId + '}]}';
                    }

                  }
                }
              }
              return json;
              //window.alert("ESte es el json " + json);
              //console.log("Este es el json " + json);

          }
          console.log("Este es el jsonFinal" + jsonFinal);
        }));

        // Changes the style for match the markup
        // Creates the default style for vertices
        var style = graph.getStylesheet().getDefaultVertexStyle();
        style[mxConstants.STYLE_STROKECOLOR] = 'gray';
        style[mxConstants.STYLE_ROUNDED] = true;
        style[mxConstants.STYLE_SHADOW] = true;
        style[mxConstants.STYLE_FILLCOLOR] = '#DFDFDF';
        style[mxConstants.STYLE_GRADIENTCOLOR] = 'white';
        style[mxConstants.STYLE_FONTCOLOR] = 'black';
        style[mxConstants.STYLE_FONTSIZE] = '12';
        style[mxConstants.STYLE_SPACING] = 4;

        // Creates the default style for edges
        style = graph.getStylesheet().getDefaultEdgeStyle();
        style[mxConstants.STYLE_STROKECOLOR] = '#0C0C0C';
        style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = 'white';
        style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
        style[mxConstants.STYLE_ROUNDED] = true;
        style[mxConstants.STYLE_FONTCOLOR] = 'black';
        style[mxConstants.STYLE_FONTSIZE] = '10';

        // Gets the default parent for inserting new cells. This
        // is normally the first child of the root (ie. layer 0).
        var parent = graph.getDefaultParent();

        // Adds cells to the model in a single step
        graph.getModel().beginUpdate();
        try {
          //var w = chapter1.getAttribute('title').length * 7;

          var v1 = graph.insertVertex(parent, null, chapter1, 40, 40, chapter1.getAttribute('title').length * 7, 30);
          var v2 = graph.insertVertex(parent, null, chapter2, 200, 150, chapter2.getAttribute('title').length * 7, 30);
          var v3 = graph.insertVertex(parent, null, chapter3, 450, 125, chapter3.getAttribute('title').length * 7, 30);
          var v4 = graph.insertVertex(parent, null, chapter4, 200, 100, chapter4.getAttribute('title').length * 7, 30);

          var e1 = graph.insertEdge(parent, null, relation, v1, v2);
          var e2 = graph.insertEdge(parent, null, relation, v2, v3);
          var e3 = graph.insertEdge(parent, null, relation, v1, v4);
          var e4 = graph.insertEdge(parent, null, relation, v4, v3);
        }
        finally {
          // Updates the display
          graph.getModel().endUpdate();
        }

        // Implements a properties panel that uses
        // mxCellAttributeChange to change properties
       graph.getSelectionModel().addListener(mxEvent.CHANGE, function (sender, evt) {
          selectionChanged(graph);
        });

        selectionChanged(graph);
      }

      /**
       * Updates the properties panel
       */
      function selectionChanged(graph) {
        var cell = null;
        //var div = document.getElementById('properties');

        // Forces focusout in IE
        graph.container.focus();

        // Clears the DIV the non-DOM way
        //div.innerHTML = '';

        // Gets the selection cell
        cell = graph.getSelectionCell();

        //Global variables
        window.savedCell = null;
        window.savedGraph = null;

        if (cell == null) {
          //var changingObject = $("#my_textBodyWidgIframe").contents().set('body','aahahahaha');
          $('#properties').hide();
          //var changingBody = changingObject.find('body').html();
          //console.log("linea de cambio = "+changingBody);

          //mxUtils.writeln(div, 'Nothing selected.');
          document.getElementById("my_textTitle").value = "Nothing selected";
          //document.getElementById("my_textBodyWidgIframe").value = "Nothing selected 2";
>>>>>>> 049663ebeb78b3f186d753c9e1ffdb68f9af9d09
        }

        // Creates the model and the graph inside the container
        // using the fastest rendering available on the browser
        var model = new mxGraphModel();
        var graph = new mxGraph(container, model);

        // Enables new connections in the graph
        graph.setConnectable(true);
        graph.setMultigraph(false);

        // Stops editing on enter or escape keypress
        var keyHandler = new mxKeyHandler(graph);
        var rubberband = new mxRubberband(graph);

        var addVertex = function(icon, w, h, style)
        {
          console.log("Entra en addVertex");
          var vertex = new mxCell(null, new mxGeometry(0, 0, w, h), style);
          vertex.setVertex(true);

          var img = addToolbarItem(graph, toolbar, vertex, icon);
          img.enabled = true;

          graph.getSelectionModel().addListener(mxEvent.CHANGE, function()
          {
            var tmp = graph.isSelectionEmpty();
            mxUtils.setOpacity(img, (tmp) ? 100 : 20);
            img.enabled = tmp;
          });
        };

        addVertex('editors/images/rectangle.gif', 100, 40, '');
        addVertex('editors/images/rounded.gif', 100, 40, 'shape=rounded');
        addVertex('editors/images/ellipse.gif', 40, 40, 'shape=ellipse');
        addVertex('editors/images/rhombus.gif', 40, 40, 'shape=rhombus');
        addVertex('editors/images/triangle.gif', 40, 40, 'shape=triangle');
        addVertex('editors/images/cylinder.gif', 40, 40, 'shape=cylinder');
        addVertex('editors/images/actor.gif', 30, 40, 'shape=actor');
      }
    }

    function addToolbarItem(graph, toolbar, prototype, image)
    {
      // Function that is executed when the image is dropped on
      // the graph. The cell argument points to the cell under
      // the mousepointer if there is one.
      var funct = function(graph, evt, cell, x, y)
      {
        graph.stopEditing(false);

        var vertex = graph.getModel().cloneCell(prototype);
        vertex.geometry.x = x;
        vertex.geometry.y = y;

        graph.addCell(vertex);
        graph.setSelectionCell(vertex);
      }

      // Creates the image which is used as the drag icon (preview)
      var img = toolbar.addMode(null, image, function(evt, cell)
      {
        var pt = this.graph.getPointForEvent(evt);
        funct(graph, evt, cell, pt.x, pt.y);
      });

      // Disables dragging if element is disabled. This is a workaround
      // for wrong event order in IE. Following is a dummy listener that
      // is invoked as the last listener in IE.
      mxEvent.addListener(img, 'mousedown', function(evt)
      {
        // do nothing
      });

      // This listener is always called first before any other listener
      // in all browsers.
      mxEvent.addListener(img, 'mousedown', function(evt)
      {
        if (img.enabled == false)
        {
          mxEvent.consume(evt);
        }
      });

      mxUtils.makeDraggable(img, graph, funct);

      return img;
    }

  </script>
</head>

<!-- Calls the main function after the page has loaded. Container is dynamically created. -->
<body onload="main();">
</body>
</html>
